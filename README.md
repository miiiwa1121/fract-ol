# fract-ol

`fract-ol`は、[MiniLibX](https://github.com/42Paris/minilibx-linux)グラフィックライブラリを使用して、美しいフラクタル図形をリアルタイムで探索できるインタラクティブなプログラムです。
このプロジェクトは、複素数平面の可視化、イベント処理、そしてグラフィックスプログラミングの基礎を学ぶことを目的としています。

## ✨ 機能

このプログラムには、以下の機能が実装されています。

  * **多彩なフラクタル**: 3種類の異なるフラクタル（マンデルブロ集合、ジュリア集合、バーニングシップ）を描画できます。
  * **無限ズーム**: マウスホイールを使って、フラクタルの細部を無限に拡大・縮小できます。
  * **マウス追従ズーム**: ズームは常にマウスカーソルの位置を中心に行われます。
  * **視点移動**: 矢印キーで表示領域を自由に移動できます。
  * **インタラクティブな色彩**: `C`キーを押すことで、サイケデリックなカラーパレットを動的に変更できます。
  * **ビューのリセット**: `R`キーでいつでも初期状態のビューに戻れます。

## Fractals

描画可能なフラクタルは以下の通りです。

1.  **Mandelbrot**: `Z = Z^2 + C` の漸化式で、`C`を変化させたときに`Z`が発散しない点の集合。
2.  **Julia**: 上記と同じ数式で、`C`を固定値とし、初期値`Z`を変化させる。`C`の値によって全く異なる模様が生まれます。
3.  **Burning Ship**: マンデルブロ集合の計算式の変形で、複素数の絶対値を取ることで、炎や船のような独特の形状を描きます。

## 🛠️ コンパイル

プロジェクトをコンパイルするには、`make`コマンドを実行してください。

```bash
make
```

これにより、`fractol`という名前の実行ファイルが生成されます。

## 🚀 使い方

以下のコマンドでプログラムを起動します。

```bash
./fractol <fractal_name> [param1] [param2]
```

### 使用例

  * **マンデルブロ集合を表示:**

    ```bash
    ./fractol mandelbrot
    ```

  * **バーニングシップを表示:**

    ```bash
    ./fractol burning_ship
    ```

  * **ジュリア集合を表示 (パラメータ指定):**
    ジュリア集合は、実部と虚部の2つのパラメータを取ります。

    ```bash
    # おすすめのパラメータ例
    ./fractol julia -0.7 0.27015
    ./fractol julia -0.8 0.156
    ```

引数が無効な場合や指定されなかった場合は、使い方が表示されます。

## 🕹️ 操作方法

| キー / マウス操作 | アクション                     |
| :---------------- | :----------------------------- |
| `マウスホイール`  | マウス位置を中心にズームイン/アウト |
| `↑` `↓` `←` `→`    | 視点の移動                     |
| `C`               | カラーパレットのシフト         |
| `R`               | 視点と色をリセット             |
| `ESC`             | プログラムを終了               |

## 📁 ディレクトリ構成

プロジェクトは、役割ごとにファイルを分離したクリーンな構成になっています。

```
.
├── Makefile
├── README.md
├── include
│   └── fractol.h
├── minilibx-linux
└── src
    ├── event_handlers.c
    ├── fractal_calculations.c
    ├── init.c
    ├── main.c
    ├── render.c
    └── utils.c
```

## 🔢 フラクタルの数学的背景

このプログラムで描画されるフラクタルは、複素数平面上での単純な漸化式の反復計算によって生まれます。ピクセルの一つ一つが複素数平面上の点に対応しており、その点が特定の計算ルールに従ったときに発散するかどうかで色が決まります。

### 1\. マンデルブロ集合 (Mandelbrot Set)

マンデルブロ集合は、以下の漸化式によって定義されます。

![alt text](image.png)

この式の各要素は以下の通りです。

  * **C**: 複素数平面上の点の座標。`render.c`でピクセルごとに計算され、この点 `C` がマンデルブロ集合に属するかどうかを判定します。
  * **Z**: 計算のたびに値が変化する複素数。初期値は常にZo=0です。
この計算を何度も繰り返したとき、`Z` の値が無限に大きくならずに、ある範囲に留まり続けるような点 `C` の集まりがマンデルブロ集合です。プログラムでは、`Z` の原点からの距離の2乗が`4.0`を超えた時点で「発散した」とみなし、その時点での繰り返し回数 `i` を返します。

### 2\. ジュリア集合 (Julia Set)

ジュリア集合は、マンデルブロ集合と全く同じ漸化式から生まれます。

![alt text](image-1.png)

しかし、`Z`と`C`の役割がマンデルブロ集合とは逆になります。

  * **Z**: 複素数平面上の点の座標。各ピクセルの位置が、計算の初期値 Zo=0 となります。
  * **C**: プログラム起動時に引数として与えられる**固定の複素数**。

この定数`C`の値を少し変えるだけで、全く異なる形の美しい図形が生まれます。これが、ジュリア集合が「パラメータによって無限のバリエーションを持つ」と言われる理由です。

### 3\. バーニングシップ (Burning Ship)

バーニングシップは、マンデルブロ集合の計算式を少し変形させたものです。基本的な構造は同じですが、`Z`の2乗を計算する際に、`Z`の実部と虚部の**絶対値**を取る点が異なります。

![alt text](image-2.png)

コード上では、虚部の計算が以下のように実装されています。

`z.im = 2.0 * fabs(z.re) * fabs(z.im) + c.im;`

`fabs()`は浮動小数点数の絶対値を取る関数です。このわずかな変更により、複素数平面の対称性が崩れ、まるで炎を上げて沈んでいく帆船のような、独特で複雑な形状が生み出されます。

## 💡 コード解説

### `include/fractol.h`
プロジェクト全体の**設計図**となるヘッダファイルです。
* `t_fractol`構造体を定義し、プログラムの状態（ズーム率、オフセット、色など）を管理します。
* キーコードやウィンドウサイズなどの定数を定義します。
* プロジェクト全体で使用される関数のプロトタイプ宣言をまとめ、異なるファイル間の連携を可能にします。
#### **イベントとキーコードの定数**
```c
/* X11 Event constants (defined directly to avoid header dependency) */
# define KEY_PRESS 2
# define BUTTON_PRESS 4
// ...
/* X11 Key codes (defined directly to avoid header dependency) */
# define ESC_KEY 65307
```
  * **由来**: これらの数字は、MiniLibXが内部で使用している**X Window System (X11)** というグラフィックシステムの標準ヘッダファイル（`X11/X.h`や`X11/keysym.h`）で定義されている値です。
  * **なぜ直接定義するのか**: 本来であれば`#include <X11/X.h>`のようにしてこれらの定数を読み込みますが、X11のヘッダファイルは非常に巨大で、不要な情報も多く含まれています。そこで、このプロジェクトで**必要な定数だけを直接書き出す**ことで、コンパイルを速くし、依存関係をシンプルに保つという意図があります。
      * `KEY_PRESS 2`: キーボードのキーが押されたイベントを示します。
      * `ESC_KEY 65307`: `ESC`キーに対応するキーコード（keysym）です。

#### **プログラム設定の定数**
```c
# define WIDTH 800
# define HEIGHT 800
# define MAX_ITER 100
```
これらはプログラムの挙動を制御する設定値です。
  * `WIDTH`, `HEIGHT`: 生成されるウィンドウの幅と高さを定義します。
  * `MAX_ITER`: フラクタルの計算を何回繰り返すかの最大値です。この値を大きくすると描画が精細になりますが、計算に時間がかかります。

### `main.c`
プログラムの**エントリーポイント**です。以下の役割を担います。
* 起動時のコマンドライン引数を検証し、表示するフラクタルの種類を決定します。
* グラフィック環境の初期化 (`fractol_init`) を呼び出します。
* イベントフックを設定 (`setup_hooks`) します。
* 最初の描画 (`fractol_render`) を行い、`mlx_loop`でイベントの待機ループを開始します。
* `int main(int argc, char **argv)`
    * **目的**: プログラム全体の実行フローを管理するエントリーポイント。
    * **処理**:
        1.  `validate_args`を呼び出し、コマンドライン引数が正しいか検証します。
        2.  `init_fractol`を呼び出し、ウィンドウやイメージ、各種変数を初期化します。
        3.  Julia集合の場合、引数で渡された値を`t_fractol`構造体に格納します。
        4.  `setup_hooks`を呼び出し、キーボードやマウスのイベントハンドラを登録します。
        5.  `render_fractol`で初期画面を描画し、`mlx_loop`でイベント待機状態に入ります。

### `src/init.c`
**初期化処理**を専門に行うファイルです。
* MiniLibXライブラリを初期化し、ウィンドウと描画用のイメージを作成します。
* `t_fractol`構造体の各変数をデフォルト値に設定します。
* `void init_fractol(t_fractol *f, int type)`
    * **目的**: `t_fractol`構造体とMiniLibX環境を初期化する。
    * **処理**:
        1.  `mlx_init`でグラフィックサーバーとの接続を確立します。
        2.  `mlx_new_window`と`mlx_new_image`でウィンドウと描画領域を作成します。
        3.  `mlx_get_data_addr`でイメージのメモリ情報を取得します。
        4.  ズーム率、オフセット、最大反復回数、ジュリアの初期パラメータなど、`t_fractol`構造体のメンバ変数をデフォルト値に設定します。

### `src/fractal_calculations.c`
フラクタルの**数学的な計算**の心臓部です。
* `mandelbrot`、`julia`、`burning_ship`といった各種フラクタルの漸化式を計算します。
* 複素数平面上の特定の点について、計算が発散するまでの繰り返し回数を返します。
* `int mandelbrot(t_complex c, int max_iter)`
    * **目的**: 点`c`がマンデルブロ集合に属するか判定する。
    * **処理**: 複素数`z`を0で初期化し、`z = z^2 + c`の計算を`max_iter`回繰り返します。途中で`z`の絶対値が2（2乗で4）を超えたら、その時点の繰り返し回数を返します。

* `int julia(t_complex z, t_complex c, int max_iter)`
    * **目的**: 点`z`が、定数`c`から生成されるジュリア集合に属するか判定する。
    * **処理**: 計算ロジックはマンデルブロと同一ですが、初期値の`z`がピクセルの座標、`c`が定数である点が異なります。

* `int burning_ship(t_complex c, int max_iter)`
    * **目的**: 点`c`がバーニングシップ集合に属するか判定する。
    * **処理**: `z = z^2 + c`の計算時に、`z`の実部と虚部の**絶対値**を取ってから2乗の計算を行います。この変更が独特の形状を生み出します。

### `src/render.c`
**描画処理**を担当します。
* ウィンドウのすべてのピクセルをスキャンし、各ピクセルに対応する複素数を計算します。
* `fractal_calculations.c`の関数を呼び出して得られた繰り返し回数に基づき、ピクセルの色を決定します。
* 最終的なイメージをウィンドウに表示します。
* `void render_fractol(t_fractol *f)`
    * **目的**: 現在の`t_fractol`の状態に基づいてフラクタルを再描画する。
    * **処理**:
        1.  `y`と`x`の二重ループで、ウィンドウの全ピクセルをスキャンします。
        2.  各ピクセル`(x, y)`の座標を、現在のズーム率とオフセットを考慮して複素数`c`に変換します。
        3.  `render_pixel`を呼び出し、そのピクセルの色を決定・描画させます。
        4.  すべてのピクセルの描画後、`mlx_put_image_to_window`で完成したイメージをウィンドウに表示します。

### `src/event_handlers.c`
キーボードやマウスからの**ユーザー入力**を処理します。
* `mlx_hook`によって登録され、イベント発生時に呼び出されます。
* キー入力（移動、色変更、リセット、終了）やマウスホイール（ズーム）に応じて`t_fractol`構造体の状態を更新し、再描画をトリガーします。
* `int handle_key(int keycode, t_fractol *f)`
    * **目的**: キーボード入力を処理する。
    * **処理**: `keycode`に応じて`t_fractol`のオフセット（矢印キー）、色シフト（`C`キー）、またはズームやオフセットのリセット（`R`キー）の値を変更し、最後に`render_fractol`を呼び出して画面を更新します。`ESC`キーの場合は`close_window`を呼び出します。

* `int handle_mouse(int button, int x, int y, t_fractol *f)`
    * **目的**: マウスボタン（特にホイール）入力を処理する。
    * **処理**: マウスホイール操作（`button 4`または`5`）を検知すると、まずマウスカーソルの座標を複素数に変換します。その後、その点を中心にズームイン・アウトするように`f->zoom`と`f->offset_x/y`の値を変更し、`render_fractol`で再描画します。

* `int close_window(t_fractol *f)`
    * **目的**: リソースを解放し、プログラムを安全に終了させる。
    * **処理**: `mlx_destroy_image`, `mlx_destroy_window`, `mlx_destroy_display`を順に呼び出してMiniLibX関連のメモリを解放し、`exit(0)`でプログラムを終了します。

### `src/utils.c`
複数の場所から利用される**補助的な便利関数**をまとめたファイルです。
* 文字列から数値への変換 (`ft_atof`) や文字列比較 (`ft_strcmp`)。
* ピクセルをイメージに描画する低レベルな関数 (`put_pixel`)。
* エラー処理や使用方法の表示など。
* `void put_pixel(t_fractol *f, int x, int y, int color)`
    * **目的**: イメージ上の指定された座標`(x, y)`に特定の色`color`のピクセルを描画する。
    * **処理**: `f->addr`（イメージの先頭アドレス）からピクセルに対応するメモリアドレスを計算し、そのアドレスに色データを直接書き込みます

## 素朴な疑問
### 